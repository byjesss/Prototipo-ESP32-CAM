// 1. LIBRERÍAS
#include <Wire.h> 
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h> // Para tu display OLED
#include <driver/ledc.h> // Si usas PWM para el Buzzer o control de potencia
#include "esp_camera.h" // Librería de la cámara
// Incluye las librerías necesarias para la cámara y el modelo
// ¡ASEGÚRATE DE QUE LOS NOMBRES SEAN CORRECTOS!
#include "edge-impulse-sdk/classifier/ei_run_classifier.h" 

// 2. DEFINICIÓN DE PINES (Corregida la sintaxis)
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

// Inicialización del display OLED (usa los pines I2C correctos)
// Si estás usando I2C:
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1); 

// Definición de Pines de Salida Digital (GPIOs)
#define LED_ROJO_NO_DETECCION   10 // <--- ¡REEMPLAZAR! Pin que se enciende si NO hay objeto
#define LED_lentes              12 // <--- ¡REEMPLAZAR! Pin para Clase 1 (Lentes)
#define LED_marcatextos         13 // <--- ¡REEMPLAZAR! Pin para Clase 2 (Marcatextos)
#define BUZZER_PIN              14 // <--- ¡REEMPLAZAR! Pin para el Buzzer

// Parámetros del modelo
const float THRESHOLD = 0.8; // Umbral de confianza para considerar una detección (ej: 80%)

// ----------------------------------------------------
// *** CÓDIGO DE INICIALIZACIÓN DE LA CÁMARA AQUÍ ***
// ESTE CÓDIGO ES EXTENSO Y ESPECÍFICO DE LA CÁMARA, LO OMITIMOS POR AHORA
// ----------------------------------------------------

void setup() {
    Serial.begin(115200);

    // Inicialización de Pines
    pinMode(LED_ROJO_NO_DETECCION, OUTPUT);
    pinMode(LED_lentes, OUTPUT);
    pinMode(LED_marcatextos, OUTPUT);
    pinMode(BUZZER_PIN, OUTPUT);
    
    // Inicialización del Display OLED
    if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // 0x3C es la dirección I2C común
        Serial.println(F("SSD1306 allocation failed"));
        for(;;); // No continuar
    }
    display.clearDisplay();
    display.setTextColor(WHITE);
    display.setTextSize(1);
    display.setCursor(0, 0);
    display.println("Inicializando...");
    display.display();

    // Inicializar la cámara (Asumimos que esta función es exitosa)
    // init_camera(); 

    // Inicializar el modelo de Edge Impulse
    if (ei_init_classifier() != EI_IMPULSE_OK) {
        Serial.println("Error al inicializar Edge Impulse");
        while (1);
    }
}

void loop() {
    // 3. EJECUCIÓN DEL MODELO (INFERENCIA)

    // Declaración de estructuras para la inferencia
    signal_t signal;
    ei_impulse_result_t result;
    bool objeto_detectado = false; // Bandera para controlar el LED rojo

    // Si la cámara captura la imagen y el clasificador se ejecuta correctamente:
    if (run_classifier(&signal, &result, false) == EI_IMPULSE_OK) {
        
        display.clearDisplay();
        display.setCursor(0, 0);
        display.println("Objeto detectado:");
        
        // Iterar sobre las clases (labels)
        for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
            
            String label = result.classification[ix].label;
            float confidence = result.classification[ix].value;

            // Imprimir resultados en el monitor serie (Sintaxis corregida)
            Serial.print(label);
            Serial.print(": ");
            Serial.println(confidence, 3); // <--- ¡CORREGIDO!
            
            // 4. LÓGICA DE ACTIVACIÓN DE INDICADORES (Cumple Puntos 3, 4 y 5 de rúbrica)
            if (confidence > THRESHOLD) {
                objeto_detectado = true; // Se detectó algo por encima del umbral

                // 4.1. Visualización en OLED
                display.setCursor(0, display.getCursorY());
                display.println(label); // Imprime el objeto detectado
                
                // 4.2. Activación de LEDs y Buzzer
                if (label == "lentes") {
                    digitalWrite(LED_lentes, HIGH);
                    digitalWrite(LED_marcatextos, LOW);
                    tone(BUZZER_PIN, 1000, 200); // Tono acústico (Punto 5)
                } else if (label == "marcatextos") {
                    digitalWrite(LED_marcatextos, HIGH);
                    digitalWrite(LED_lentes, LOW);
                    tone(BUZZER_PIN, 500, 200); // Tono acústico diferente
                }
                // Si tienes más clases, añade más 'else if'
            } else {
                // Si la confianza es baja, apagar el LED específico de esa clase para ese ciclo
                if (label == "lentes") digitalWrite(LED_lentes, LOW);
                if (label == "marcatextos") digitalWrite(LED_marcatextos, LOW);
            }
        } // Fin del bucle de clases

        // 4.3. Control del LED Rojo (Punto 4)
        if (objeto_detectado) {
            digitalWrite(LED_ROJO_NO_DETECCION, LOW); // Apaga el rojo si algo fue detectado
        } else {
            digitalWrite(LED_ROJO_NO_DETECCION, HIGH); // Enciende el rojo si NO hay detección
            display.setCursor(0, display.getCursorY());
            display.println("Esperando...");
            noTone(BUZZER_PIN);
        }
        
        display.display();
    }
    delay(100); // Pequeña pausa entre inferencias
}
